# üìò Big O Interview Questions ‚Äì Quick Reference




### 1. What is Big O notation?

**Answer:** It describes the upper bound of an algorithm‚Äôs growth rate in terms of time or space complexity.

---

### 2. What is the Big O of accessing an array element by index?

**Answer:** O(1) ‚Äì Constant time.

---

### 3. What is the time complexity of binary search?

**Answer:** O(log n)

---

### 4. What is the time complexity of bubble sort?

**Answer:** O(n¬≤)

---

### 5. What is the space complexity of merge sort?

**Answer:** O(n) ‚Äì due to auxiliary arrays.

---

### 6. What is the time complexity of a hash table insertion (average case)?

**Answer:** O(1)

---

### 7. What is the worst-case time complexity of hash table operations?

**Answer:** O(n) ‚Äì in case of many collisions.

---

### 8. What is the time complexity of inserting into a binary search tree (average case)?

**Answer:** O(log n)

---

### 9. What‚Äôs the worst-case time complexity of quicksort?

**Answer:** O(n¬≤)

---

### 10. What‚Äôs the average-case time complexity of quicksort?

**Answer:** O(n log n)

---

### 11. What‚Äôs the time complexity of iterating over all elements in a linked list?

**Answer:** O(n)

---

### 12. Which data structure allows O(1) time insertion and deletion at both ends?

**Answer:** Deque (Double-ended Queue)

---

### 13. What is the Big O of checking if a value exists in a balanced BST?

**Answer:** O(log n)

---

### 14. What is the time complexity of a nested loop iterating over the same array?

**Answer:** O(n¬≤)

---

### 15. What is the best time complexity for a comparison-based sorting algorithm?

**Answer:** O(n log n)

---

### 16. What is the time complexity of the naive recursive Fibonacci algorithm?

**Answer:** O(2‚Åø)

---

### 17. What‚Äôs the time complexity of dynamic programming Fibonacci?

**Answer:** O(n)

---

### 18. Why is O(n log n) better than O(n¬≤)?

**Answer:** It grows slower for large inputs, making it more scalable.

---

### 19. What is amortized time complexity?

**Answer:** It averages the time over a sequence of operations (e.g., O(1) for dynamic array resizing).

---

### 20. How do you compare O(n), O(n¬≤), and O(1) in terms of performance?

**Answer:** O(1) < O(n) < O(n¬≤) ‚Äì Lower complexity is better for scalability.

---
